<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>红黑树</title>
</head>
<body>
    <h1>红黑树</h1>
    <h2>基本规则</h2>
    <p>1. 节点是红色或黑色</p>
    <p>2.根节点是黑色</p>
    <p>3.每个叶子节点都是黑色的空节点</p>
    <p>4.每个红色节点的两个子节点都是黑色的（从每个叶子到根的所有路径上不能有两个连续的红色节点）</p>
    <p>5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</p>
    <h2>相对平衡</h2>
    <h3>关键特性</h3>
    <p>从根到叶子的最长可能路径，不会超过最短路径的两倍</p>
    <p>结果就是这个树基本平衡</p>
    <p>虽然没有做到绝对平衡，但可以保证在最坏情况下依然高效</p>
    <h3>为什么可以做到最长路径不超过最短路径两倍</h3>
    <p>规则4决定了路径不能有两个相连的红色节点</p>
    <p>最短可能路径都是黑色节点</p>
    <p>最长可能路径是红色黑色交替</p>
    <p>规则5所有路径都有相同数目的黑色节点</p>
    <p>表明了没有路径能多余任何其他路径的两倍长</p>
    <h2>红黑树的变换</h2>
    <h3>变色</h3>
    <p>插入一个新节点时，有可能树不再平衡，可以通过三种方式变换，让树保持平衡：  换色-左旋转-右旋转</p>
    <h2>插入操作</h2>
    <p>情况1：新节点位于树的跟上，没有父节点（直接将红色变换为黑色） </p>
    <p>情况2：新节点的父节点时黑色，不需要改变</p>
    <p>情况3：父红叔红祖黑  ——>  父黑叔黑祖红 </p></p>
    <p>情况4：N的叔叔是黑节点，N是孩子（父红叔黑祖黑，N是左儿子）： 父黑祖红右旋转</p>
    <p>情况4：N的叔叔是黑节点，N是有孩子(父红叔黑祖黑，N是有儿子)：以P为根，左旋转， 将P作为新插入的红色节点考虑，   </p>

</body>
</html>